---
title: "Lab04 - Monte Carlo Methods in R"
author: "Jarad Niemi"
date: "`r Sys.Date()`"
output: html_document
---


To follow along, use the [lab04 code](lab04.R).

## Programming in R

R is made up primarily of 

- objects
- functions

We discussed many R objects in [lab 02](../lab02/lab02.html), 
but there are many more.

### Functions

Functions are written to be performed on objects.
The function below simply adds 1 to whatever the argument is. 

```{r}
add1 <- function(a) {
  return(a+1)
}

add1(2)
add1(a = 3)
```

The following function adds the two arguments.

```{r}
add <- function(a, b) {
  return(a+b)
}

add(1,1)
add(a = 2, b = 3)
```

Many functions in R are vectorized meaning they can take vector arguments and
return a sensible value. 
As written, our functions are vectorized, e.g. 

```{r}
add1(a = 1:2)
add(a = 1:2, b = 3:4)
```

This is usually helpful, but it is not always clear what the results should be.
For example, what do you think the result is if you run

```{r, eval=FALSE}
add(a = 1:4, b = 1:2)
```



### Arguments

Arguments to functions can be provided by order or by name or both. 
You can also specify arguments using a partial name.

```{r}
f <- function(first, second) {
  return(first/2 + second)
}

f(1,2)
f(1, second = 2)
f(first = 1, second = 2)
f(second = 2, 1) # I thought this was going to be an error
f(f = 1, s = 2)
```

My suggestion is that you always use argument full names when writing your code.
Due to RStudio's tab-autocomplete, typing in the full name should not slow you 
down.


Many functions have default arguments. 
You can specify default arguments in the functions you write by using the `=`
sign in the function definition.

```{r}
add <- function(a, b = 1) {
  return(a+b)
}

add(a = 1)
add(a = 1:2)
add(a = 2:3, b =  2)
add(a = 3:4, b = -1)
```

For example, the `norm` functions have default arguments that correspond to a 
standard normal, i.e. `mean=0` and `sd=1`. 

```{r}
hist(rnorm(1e6), probability = TRUE)
curve(dnorm(x), add = TRUE, col = 'red')
```


#### Function activity

Create a function with arguments named `first` and `second` and have the 
function subtract the second argument from the first.
Provide a default for `first` that is the vector `1:2` and  for `second`
that is the value `1`. 

<div id="function_activity_solution" style="display:none"> 
```{r, purl=FALSE}
sub <- function(first = 1:2, second = 1) {
  return(first - second)
}
```
</div> 
<button title="Show a solution" type="button" onclick="if(document.getElementById('function_activity_solution') .style.display=='none') {document.getElementById('function_activity_solution') .style.display=''}else{document.getElementById('function_activity_solution') .style.display='none'}">Show/Hide Solution</button>



### Generic Functions

R has generic functions, i.e. functions where the type of object passed as the 
first argument to the function determine which function to actually run.
The `print()` function is a generic function

```{r, eval=FALSE}
?print
```

Notice in the help file it says "It is a generic function".

To determine exactly what function will be executed when using the a generic 
function, you need to determine the `class` of the object.

Here is an example

```{r}
n <- 10
x <- rnorm(n)
y <- rnorm(n, x)
m <- lm(y~x) # a linear regression
print(m)
```
Here `print()` checked the class of `m`

```{r}
class(m)
```
and found that the class is `lm` and uses the appropriate print function. 

There are other helpful functions for `lm` objects, e.g. 

```{r}
summary(m)
anova(m)
plot(m)
```

### Scope

The objects available to an R function are defined by the scope of the function.
But if the object is not available within the function, then the function will
look to the environment containing that function to see if the object is there.

```{r}
a <- 1
f <- function() {
  return(a)
}
f()
```

If we modify the object within the function, that version of the object is 
only available within the function.

```{r}
f <- function() {
  a <- 2
  return(a)
}
f()
a
```

Unless we use a special assignment operator `<<-`

```{r}
f <- function() {
  a <<- a + 1
  return(a)
}
a
f()
a
```
So be careful when constructing functions to deal appropriately with the 
scope of the objects you are using.

### Loops

Basic programming often consists of using loops and conditionals.
R has `for` and `while` loops as well as `if`-`else` statements.

Here is a basic `for` loop:
```{r}
for (i in 1:3) {
  print(i)
}
```


A basic `while` loop:
```{r}
i <- 0
while (i < 3) {
  i <- i + 1
  print(i)
}
```

And a basic use of the `if`-`else` statement:
```{r}
for (i in 1:10) {
  if (i<5) {
    print(-i)
  } else {
    print(i*2)
  }
}
```

There is also a useful `ifelse` statement, but it is a little confusing.
This statement takes in a vector logical first argument and two more scalar 
arguments. 
For each element in the logical vector, it will return the first scalar argument
when the element is true and the second scalar argument when the elemtn is 
false.

```{r}
ifelse((1:10) < 5, "Less than 5", "Not less than 5")
```


#### Loop activity

Create a function that has a single scalar argument named `a`. 
Use a loop inside the function to calculate the sum of the numbers
from 1 to a and return this sum.
Test using the sum up to 100 which should be 5050.

<div id="loop_activity_solution" style="display:none"> 
```{r, purl=FALSE}
f <- function(a) {
  sum <- 0
  for (i in 1:a) {
    sum <- sum + i
  }
  return(sum)
}
f(100)
```
</div> 
<button title="Show a solution" type="button" onclick="if(document.getElementById('loop_activity_solution') .style.display=='none') {document.getElementById('loop_activity_solution') .style.display=''}else{document.getElementById('loop_activity_solution') .style.display='none'}">Show/Hide Solution</button>




## Monte Carlo Methods in R

